#!/usr/bin/env glas.concept

Hi.

This is the Main concept file of the whole Glas project:
 * A translator for
 * Glas language syntax into/backfrom Python
 * A system for defining, and linking modules written in ANY language. 
    Check out Glas.Lang.Any for more!
    
    Glas should be the ultimate Glue System and General Purpose High Level 
    Language.
    
    In fact, Glas is closer to English rather than any other computer 
    language. Check out /Genesis.glas for a glimpse at this weird syntax.
    
    You might be amazed at how close Glas is to English, and how much
     expression power it gives to the speaker! Even too much!
     
    A Glas directory looks like Bikini island during Nuclear testing!
    
    For instance in English you say:
        "Why is the cookie jar empty, Cookie Monster? Why??!?"
        
    In Glas you would say:
        why: cookie jar ~ empty: -> Cookie Monster ~ why: "??!?"
    
    and that would have the effect of:
        Cookie_Monster.why(cookie_jar.empty()).why("??!?")
    in Python
    
    Say you're the boss of a big multinational, may be you might say:
        "Give me Petrov's legal documents, Debbie... Now!"
    in Glas that would yell from your screen like this:
    
        give: Petrov ~ legal: ->> documents -> Debbie ~ now: # ?timedate
    
    in Old Pythonic that would be:
        Debbie.give(Petrov.documents.legal()).now()
 
    Glas is refactor resilient!
    
    For instance let's say we've got this code:
    
    Petrov ~ give: me, object # Petrov.give(me, object)
    
    Or, "Petrov, give me that object" right?
    Well yeah, but the bastards changed the api to be in effect 
    # me.give( Petrov, object ) # We changed the logic to be 
                                # Person.recieve(from) like and blablablabl
                                #  ablab lablabla
    
    which was a rather STUPID move, but check this out, our Glas'y sentence
    still stands out in the same wording as before!
    
    Petrov <- give: object -> me
    
Idealy, you would write language transformation modules (Glas.Dictionary)ies
 and you would use glas* for translating (on the fly or not, doesn't matter)
 Glas modules into any other compatible language.
 
For instance, you would want for a large project to have alternatives 
 of the main code base in any language.

That's why you start wiring your project (not writing, wiring) using Glas
 and then you start compiling different parts into different compilation
 tasks.

This way, you can start for example a new Unix like operating system in 
 Glas, and using the glas system you would simply compile and translate 
 the kernel modules of it into C modules (source files) which you further 
 would either compile and run, or modify by hand to run them!

The whole system including configuration languages and data markup languages
 (xml based GUI modules? Glas modules!) could be defined and produced 
 by the Glas system. The glas.py could also be your main shell.
 
In fact, the first thing you would do creating your own kernel, is to
 put Glas in it. 
 
Sorry but that's hilarious for some reason, i don't know why.

Later on, you would built yourself from the ground up using Glas, like
 baron Munchausen pulling himself by the hair. Much like original Unix/C, 
 but EASIER, in the far far future of 21st century ;-)
 
--Borko

Enjoy!

